const { readFileSync } = require("fs")
const { PrismaClient } = require("@prisma/client")
const prisma = new PrismaClient()

async function clearAllTables() {
    console.log("üßπ –ù–∞—á–∏–Ω–∞–µ–º –æ—á–∏—Å—Ç–∫—É —Ç–∞–±–ª–∏—Ü...")

    async function clearTable(model, tableName) {
        try {
            const count = await model.count()
            if (count > 0) {
                await model.deleteMany({})
                console.log(`‚úÖ –¢–∞–±–ª–∏—Ü–∞ "${tableName}" –æ—á–∏—â–µ–Ω–∞`)
            } else {
                console.log(`üü° –¢–∞–±–ª–∏—Ü–∞ "${tableName}" –ø—É—Å—Ç–∞, –ø—Ä–æ–ø—É—â–µ–Ω–∞`)
            }
        } catch (e) {
            console.log(`‚ö†Ô∏è –¢–∞–±–ª–∏—Ü–∞ "${tableName}" –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ ‚Äî –ø—Ä–æ–ø—É—â–µ–Ω–∞`)
        }
    }
    await clearTable(prisma.cartSkin, "cartSkin")
    await clearTable(prisma.orderSkin, "orderSkin")
    await clearTable(prisma.weeklyProducts, "weeklyProducts")
    await clearTable(prisma.lastBuy, "lastBuy")

    await clearTable(prisma.cart, "cart")
    await clearTable(prisma.order, "order")

    await clearTable(prisma.skin, "skin")
    await clearTable(prisma.game, "game")
    await clearTable(prisma.rarity, "rarity")
    await clearTable(prisma.type, "type")
    await clearTable(prisma.model, "model")
    await clearTable(prisma.souvenir, "souvenir")
    await clearTable(prisma.exterior, "exterior")
    await clearTable(prisma.killCounter, "killCounter")
    await clearTable(prisma.phase, "phase")
    await clearTable(prisma.hero, "hero")
    await clearTable(prisma.slot, "slot")
    await clearTable(prisma.quality, "quality")
    await clearTable(prisma.category, "category")

    console.log("‚úÖ –í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã")
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        ;[array[i], array[j]] = [array[j], array[i]]
    }
    return array
}
async function updateCategoriesWithPreviews() {
    console.log("üîÑ –ù–∞—á–∏–Ω–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Å –ø—Ä–µ–≤—å—é...")

    const categories = await prisma.category.findMany({
        include: {
            model: true,
        },
    })

    for (const category of categories) {
        console.log(`üìÅ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é: ${category.name}`)

        for (const model of category.model) {
            if (!model.previewSkinId) {
                const previewSkin = await prisma.skin.findFirst({
                    where: { modelId: model.id },
                })

                if (previewSkin) {
                    await prisma.model.update({
                        where: { id: model.id },
                        data: { previewSkinId: previewSkin.id },
                    })

                    console.log(`‚úÖ –ü—Ä–µ–≤—å—é —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è model "${model.name}"`)
                } else {
                    console.log(`‚ö† –ù–µ –Ω–∞–π–¥–µ–Ω —Å–∫–∏–Ω –¥–ª—è model "${model.name}"`)
                }
            } else {
                console.log(`‚è≠ –ü—Ä–æ–ø—É—â–µ–Ω–æ: –ü—Ä–µ–≤—å—é —É–∂–µ –µ—Å—Ç—å –¥–ª—è "${model.name}"`)
            }
        }
    }

    console.log("‚úÖ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã")
}

function generateSlug(name) {
    return name
        .normalize("NFKC")
        .toLowerCase()
        .replace(/[^a-z–∞-—è—ë0-9\s-]/gimu, "")
        .replace(/[\s_]+/g, "-")
        .replace(/-+/g, "-")
        .replace(/^-|-$/g, "")
}

const CATEGORY = {
    knife: "–ù–æ–∂",
    pistol: "–ü–∏—Å—Ç–æ–ª–µ—Ç",
    rifle: "–ê–≤—Ç–æ–º–∞—Ç",
    sniper: "–°–Ω–∞–π–ø–µ—Ä—Å–∫–∞—è –≤–∏–Ω—Ç–æ–≤–∫–∞",
    machinegun: "–ü—É–ª–µ–º—ë—Ç",
    smg: "–ü–∏—Å—Ç–æ–ª–µ—Ç-–ø—É–ª–µ–º—ë—Ç",
    shotgun: "–î—Ä–æ–±–æ–≤–∏–∫",
    gloves: "–ü–µ—Ä—á–∞—Ç–∫–∏",
    sticker: "–°—Ç–∏–∫–µ—Ä",
}
const RARITY = {
    –¢–∞–π–Ω–æ–µ: "Covert",
    –ó–∞–ø—Ä–µ—â—ë–Ω–Ω–æ–µ: "Restricted",
    –ó–∞—Å–µ–∫—Ä–µ—á–µ–Ω–Ω–æ–µ: "Classified",
    "–ê—Ä–º–µ–π—Å–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ": "Mil-Spec Grade",
    "–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ": "Industrial Grade",
    –®–∏—Ä–ø–æ—Ç—Ä–µ–±: "Consumer Grade",
    –ö–æ–Ω—Ç—Ä–∞–±–∞–Ω–¥–∞: "Contraband",
    "–≠–∫—Å—Ç—Ä–∞–æ—Ä–¥–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ç–∏–ø–∞": "Extraordinary",
    "–ü—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–∏–ø–∞": "Remarkable",
    "–í—ã—Å—à–µ–≥–æ –∫–ª–∞—Å—Å–∞": "Master",
    "–≠–∫–∑–æ—Ç–∏—á–Ω–æ–≥–æ –≤–∏–¥–∞": "Exotic",
}
const EXTERIOR = {
    "–ü—Ä—è–º–æ —Å –∑–∞–≤–æ–¥–∞": "Factory New",
    "–ù–µ–º–Ω–æ–≥–æ –ø–æ–Ω–æ—à–µ–Ω–Ω–æ–µ": "Minimal Wear",
    "–ü–æ—Å–ª–µ –ø–æ–ª–µ–≤—ã—Ö –∏—Å–ø—ã—Ç–∞–Ω–∏–π": "Field-Tested",
    –ü–æ–Ω–æ—à–µ–Ω–Ω–æ–µ: "Well-Worn",
    "–ó–∞–∫–∞–ª—ë–Ω–Ω–æ–µ –≤ –±–æ—è—Ö": "Battle-Scarred",
}
const TYPE = {
    –ù–∞–±–æ—Ä: "Set",
    –£–∫—Ä–∞—à–µ–Ω–∏–µ: "Wearable",
    –°–æ–∫—Ä–æ–≤–∏—â–Ω–∏—Ü–∞: "Crate",
    –ö–æ–º–º–µ–Ω—Ç–∞—Ç–æ—Ä: "Announcer",
    –ö—É—Ä—å–µ—Ä: "Courier",
    –ù–∞–∫–ª–µ–π–∫–∞: "Sticker",
    –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: "Tool",
    –ù–∞—Å–º–µ—à–∫–∞: "Taunt",
    –†–∞–∑–Ω–æ–µ: "Miscellaneous",
    –ú—É–∑—ã–∫–∞: "Music",
    "–°–∞–º–æ—Ü–≤–µ—Ç/—Ä—É–Ω–∞": "Gem/Rune",
    "–°—Ç–∏–ª—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞": "User Interface Style",
    –í–∞—Ä–¥: "Ward",
    "–ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–π —ç–∫—Ä–∞–Ω": "Loading Screen",
    "–ù–∞–±–æ—Ä –∫—É—Ä—Å–æ—Ä–æ–≤": "Cursor Set",
    "–ö–ª—é—á –æ—Ç —Å–æ–∫—Ä–æ–≤–∏—â–Ω–∏—Ü—ã": "Key",
    –õ–∞–Ω–¥—à–∞—Ñ—Ç: "Environment",
    –û—Ä—É–∂–∏–µ: "weapon",
    –ë—Ä–æ–Ω—è: "armor",
    –û–¥–µ–∂–¥–∞: "clothes",
    –†–µ—Å—É—Ä—Å—ã: "resource",
    –†–∞–∑–Ω–æ–µ: "other",
    –î—Ä—É–≥–æ–µ: "another",
}

const SLOTS = {
    –ü–æ—è—Å: "Belt",
    –ì–æ–ª–æ–≤–∞: "Head",
    "–ü—Ä–∏–∑–≤–∞–Ω–Ω–æ–µ —Å—É—â–µ—Å—Ç–≤–æ": "Summon",
    –†—É–∫–∏: "Hands",
    –ñ–∏–≤–æ—Ç–Ω–æ–µ: "Creature",
    –û—Ä—É–∂–∏–µ: "Weapon",
    –ü–ª–µ—á–∏: "Shoulders",
    "–î–æ–ø. –æ—Ä—É–∂–∏–µ": "Off-Hand Weapon",
    –°–ø–∏–Ω–∞: "Back",
    –ö–æ–º–º–µ–Ω—Ç–∞—Ç–æ—Ä: "Announcer",
    "2-—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å": "Secondary Ability",
    "3-—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å": "Tertiary Ability",
    –†–∞–∑–Ω–æ–µ: "Miscellaneous",
    –ë—Ä–æ–Ω—è: "Armor",
    –ö—É—Ä—å–µ—Ä: "Courier",
    –®–µ—è: "Neck",
    –ù–∞—Å–º–µ—à–∫–∞: "Taunt",
    –£–ª—å—Ç: "Ultimate",
    –ö–æ—Å—Ç—é–º: "Costume",
    –ü–æ–≥–æ–¥–∞: "Weather Effect",
    "4-—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å": "Quaternary Ability",
    –ú—É–∑—ã–∫–∞: "Music",
    –•–≤–æ—Å—Ç: "Tail",
    "–¢–µ–ª–æ/–≥–æ–ª–æ–≤–∞": "Body/Head",
    –î—Ä–µ–≤–Ω–∏–µ: "Ancient",
    "–°—Ç–∏–ª—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞": "User Interface Style",
    –í–∞—Ä–¥: "Ward",
    "–ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–π —ç–∫—Ä–∞–Ω": "Loading Screen",
    –ì–æ–ª–æ—Å: "Voice",
    "–ú–µ–≥–∞-—É–±–∏–π—Å—Ç–≤–∞": "Mega Kill",
    "–û–±–ª–∏–∫ –≤–æ–ª–∫–∞": "Wolf Form",
    –ù–æ–≥–∏: "Legs",
    –ü–µ—Ä—á–∞—Ç–∫–∏: "Gloves",
    "–°–æ–æ–±—â–µ–Ω–∏—è –æ —Å–µ—Ä–∏–∏ —É–±–∏–π—Å—Ç–≤": "Kill Series Message",
    "–ù–∞–±–æ—Ä –∫—É—Ä—Å–æ—Ä–æ–≤": "Cursor Set",
    "–ë–∞—à–Ω–∏ —Å–∏–ª –°–≤–µ—Ç–∞": "Radiant Tower",
    "–ë–∞—à–Ω–∏ —Å–∏–ª –¢—å–º—ã": "Dire Tower",
    –õ–∞–Ω–¥—à–∞—Ñ—Ç: "Environment",
}

async function findOrCreate(modelName, nameRaw, extraData = {}) {
    if (!nameRaw || nameRaw.trim() === "") return null

    const model = prisma[modelName]
    const trimmedName = nameRaw.trim()

    try {
        let createData = { name: trimmedName }

        if (modelName === "category") {
            createData.name = trimmedName
            createData.ruName = CATEGORY[trimmedName] || trimmedName
        }
        if (modelName === "rarity") {
            createData.name = RARITY[trimmedName] || trimmedName
            createData.ruName = trimmedName
        }
        if (modelName === "exterior") {
            createData.name = EXTERIOR[trimmedName] || trimmedName
            createData.ruName = trimmedName
        }
        if (modelName === "killCounter") {
            if (trimmedName === "statTrak") {
                createData.name = trimmedName
                createData.ruName = "StatTrak‚Ñ¢"
                createData.flag = true
            } else {
                createData.name = trimmedName
                createData.ruName = "–ë–µ–∑ StatTrak‚Ñ¢"
                createData.flag = false
            }
        }
        if (modelName === "souvenir") {
            if (trimmedName === "souvenir") {
                createData.name = trimmedName
                createData.ruName = "–°—É–≤–µ–Ω–∏—Ä–Ω–æ–µ"
                createData.flag = true
            } else {
                createData.name = trimmedName
                createData.ruName = "–ù–µ –°—É–≤–µ–Ω–∏—Ä–Ω–æ–µ"
                createData.flag = false
            }
        }
        if (modelName === "model") {
            createData.categoryId = extraData.categoryId || null
        }
        if (modelName === "rarity" || modelName === "type") {
            createData.gameId = extraData.gameId || null
        }

        if (modelName === "slot") {
            createData.name = SLOTS[trimmedName]
            createData.ruName = trimmedName
        }
        if (modelName === "type") {
            createData.name = TYPE[trimmedName]
            createData.ruName = trimmedName
        }

        const record = await model.upsert({
            where: { name: createData.name },
            update: {},
            create: createData,
        })

        return record.id
    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ ${modelName} "${trimmedName}":`, error.message)
        return null
    }
}

async function importSkinsFromJSON(filePath) {
    const modelMap = {}

    console.log("üöÄ –ù–∞—á–∏–Ω–∞–µ–º –∏–º–ø–æ—Ä—Ç JSON...")

    const rawData = readFileSync(filePath, "utf8")
    const data = shuffleArray(JSON.parse(rawData))

    let rowCount = 0

    for (const row of data) {
        rowCount++

        try {
            const gameId = await findOrCreate("game", row.game)
            const categoryId = await findOrCreate("category", row.category)
            const exteriorId = await findOrCreate("exterior", row.exterior)
            const modelId = await findOrCreate("model", row.model, { categoryId })
            const phaseId = await findOrCreate("phase", row.phase)
            const slotId = await findOrCreate("slot", row.slot)
            const heroId = await findOrCreate("hero", row.hero)
            const qualityId = await findOrCreate("quality", row.quality)
            const slug = generateSlug(row.name)

            const rarityId = await findOrCreate("rarity", row.rarity, { gameId })
            const typeId = await findOrCreate("type", row.type, { gameId })

            let uniqueSlug = slug
            let counter = 1

            while (true) {
                const existing = await prisma.skin.findUnique({
                    where: { slug: uniqueSlug },
                })
                if (!existing) break
                uniqueSlug = `${slug}-${counter}`
                counter++
            }
            let souvenirId = null
            let killCounterId = null

            if (row.game === "cs2") {
                if (row.souvenir === true) {
                    souvenirId = await findOrCreate("souvenir", "souvenir")
                } else {
                    souvenirId = await findOrCreate("souvenir", "noSouvenir")
                }
                if (row.statTrak === true) {
                    killCounterId = await findOrCreate("killCounter", "statTrak")
                } else {
                    killCounterId = await findOrCreate("killCounter", "noStatTrak")
                }
            }

            if (row.model && !modelMap[row.model]) {
                modelMap[row.model] = modelId
            }

            await prisma.skin.create({
                data: {
                    name: row.name.trim(),
                    price: parseFloat(row.price),
                    imageUrl: row.imageUrl.trim(),
                    image: row.image.trim(),
                    description: row.description || null,
                    categoryId,
                    gameId,
                    exteriorId,
                    rarityId,
                    modelId,
                    phaseId,
                    souvenirId,
                    killCounterId,
                    slug: uniqueSlug,
                    slotId,
                    typeId,
                    heroId,
                    qualityId,
                },
            })

            console.log(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω —Å–∫–∏–Ω (${rowCount}): ${row.name}`)
        } catch (error) {
            console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ "${row.name}":`, error.message)
        }
    }

    console.log(`\nüéâ –ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω! –í—Å–µ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ: ${rowCount} –∑–∞–ø–∏—Å–µ–π`)
    return modelMap
}

const JSON_FILE_CS = "./skins-cs.json"
const JSON_FILE_DOTA = "./skins-dota.json"
const JSON_FILE_RUST = "./skins-rust.json"

;(async () => {
    try {
        await clearAllTables()

        await importSkinsFromJSON(JSON_FILE_CS)
        await importSkinsFromJSON(JSON_FILE_DOTA)
        await importSkinsFromJSON(JSON_FILE_RUST)
        await updateCategoriesWithPreviews()
    } catch (error) {
        console.error("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞:", error.message)
        process.exit(1)
    } finally {
        await prisma.$disconnect()
    }
})()
